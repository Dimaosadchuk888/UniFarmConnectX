# Аудит клиентской части UniFarm

## 1. Отображение реферального кода (ref_code)

| Компонент | Статус | Комментарий |
|-----------|--------|-------------|
| `UniFarmReferralLink.tsx` | ⚠️ Требует исправления | Многократные запросы к API, сложная логика восстановления, избыточные обновления |
| API вызов `/api/me` | ✅ OK | Корректно вызывается, возвращает ref_code |
| Отображение в UI | ⚠️ Требует исправления | Иногда ref_code не отображается при первой загрузке |

**Выявленные проблемы:**
- Компонент `UniFarmReferralLink.tsx` выполняет избыточные запросы к API (строки 35-83)
- Присутствует двойная логика получения данных: и от родителя, и через собственный запрос
- Используется `refetchOnWindowFocus: true` и `staleTime: 0`, что вызывает частые запросы при переключении между вкладками
- Генерация ref_code выполняется автоматически в useEffect (строки 190-223), что может вызывать нежелательное поведение

**Рекомендации:**
- Упростить логику получения данных - использовать один источник (либо родитель, либо собственный запрос)
- Увеличить staleTime для уменьшения количества запросов
- Генерацию ref_code выполнять только по явному запросу пользователя

## 2. Логика кнопки "Пополнить" (депозит UNI)

| Компонент | Статус | Комментарий |
|-----------|--------|-------------|
| `UniFarmingCard.tsx` | ⚠️ Требует исправления | Избыточная обработка типов, дублирование логики, есть уязвимости |
| Валидация amount | ✅ OK | Проверяется что amount > 0 и конвертируется в строку |
| Обработка ошибок | ⚠️ Требует исправления | Много уровней try/catch с разным поведением |

**Выявленные проблемы:**
- Метод `handleSubmit` содержит избыточную обработку типов для amount (строки 113-216)
- Происходит многократное преобразование amount из числа в строку (строки 157, 175-178, 215-216)
- Имеется 3 уровня вложенных try/catch блоков, что затрудняет отслеживание ошибок
- Прямое использование fetch вместо централизованного apiRequest (строки 195-238)

**Рекомендации:**
- Упростить логику преобразования типов, использовать единый подход
- Объединить обработку ошибок в более компактную структуру
- Использовать централизованный apiRequest с корректной обработкой типов

## 3. Поведение при открытии Mini App

| Компонент | Статус | Комментарий |
|-----------|--------|-------------|
| `App.tsx` | ⚠️ Требует исправления | Много useEffect с дублированием логики |
| Инициализация | ⚠️ Требует исправления | Избыточные проверки в консоль и много вызовов |
| Восстановление сессии | ⚠️ Требует исправления | Сложная логика, много условий и проверок |

**Выявленные проблемы:**
- В App.tsx присутствуют несколько useEffect для инициализации (строки 81-100, 102-109, 125-145)
- Большое количество вызовов console.log затрудняет отладку
- Сессия восстанавливается несколькими способами, что может вызывать race condition
- Возможно выполнение нескольких запросов при загрузке

**Рекомендации:**
- Объединить логику инициализации в один useEffect с четким порядком действий
- Уменьшить количество отладочных сообщений
- Упростить процесс восстановления сессии

## 4. Отображение баланса, депозита и доходности

| Компонент | Статус | Комментарий |
|-----------|--------|-------------|
| Запросы к `/api/uni-farming/info` | ⚠️ Требует исправления | queryKey содержит статичный ID вместо динамического |
| Обновление после сбора | ⚠️ Требует исправления | Используется нестандартный запрос вместо useMutation |
| Форматирование значений | ✅ OK | Корректная обработка малых значений |

**Выявленные проблемы:**
- В запросе к `/api/uni-farming/info` используется захардкоженный `user_id=1` (строка 31 в UniFarmingCard.tsx)
- Для запроса harvest используется прямой fetch вместо useMutation (строки 67-75)
- Обновление баланса после операций выполняется через queryClient.invalidateQueries, но с неточными ключами

**Рекомендации:**
- Использовать динамический user_id из контекста пользователя
- Заменить прямые fetch на useMutation
- Согласовать queryKeys для правильного обновления кэша

## 5. Блок миссий, партнёров и бустов

| Компонент | Статус | Комментарий |
|-----------|--------|-------------|
| Загрузка миссий | ❓ Требует проверки | Не удалось найти соответствующий компонент |
| Бусты | ❓ Требует проверки | Компоненты найдены, но логика неясна |
| Дерево рефералов | ⚠️ Требует исправления | Проблемы с обновлением и форматированием |

**Выявленные проблемы:**
- Не удалось полностью проанализировать логику загрузки миссий
- В компонентах для бустов могут быть проблемы обновления данных
- Дерево рефералов может некорректно отображаться при отсутствии данных

**Рекомендации:**
- Требуется дополнительный анализ компонентов для миссий и бустов
- Проверить обработку пустых данных в компонентах

## 6. Обработка ошибок в интерфейсе

| Компонент | Статус | Комментарий |
|-----------|--------|-------------|
| Try/catch блоки | ⚠️ Требует исправления | Разная логика обработки в разных компонентах |
| Отображение ошибок | ⚠️ Требует исправления | Не всегда отображаются понятные сообщения |
| Валидация запросов | ⚠️ Требует исправления | Нестандартная валидация между компонентами |

**Выявленные проблемы:**
- Отсутствует единый подход к обработке ошибок
- В некоторых компонентах ошибки только логируются, но не отображаются пользователю
- Валидация типов данных в запросах делается разными способами (queryClient.ts, UniFarmingCard.tsx)

**Рекомендации:**
- Создать единый механизм обработки и отображения ошибок
- Стандартизировать валидацию данных в запросах
- Добавить понятные пользовательские сообщения об ошибках

## Общие рекомендации:

1. **Стандартизация запросов к API**:
   - Всегда использовать централизованный apiRequest вместо прямых fetch
   - Согласовать queryKeys для правильного обновления кэша

2. **Упрощение логики компонентов**:
   - Уменьшить количество вложенных условий и try/catch блоков
   - Вынести повторяющуюся логику в хуки или утилиты

3. **Улучшение обработки ошибок**:
   - Создать единый механизм обработки и отображения ошибок
   - Добавить понятные сообщения для пользователя

4. **Оптимизация производительности**:
   - Уменьшить количество запросов к API
   - Увеличить использование кэширования

5. **Улучшение типизации**:
   - Использовать строгую типизацию для всех компонентов
   - Стандартизировать преобразование типов данных