/**
 * Утилиты для работы с реферальными кодами
 */

import { db } from "../db";
import { users } from "@shared/schema";
import { eq } from "drizzle-orm";
import { storage } from "../storage";
import crypto from "crypto";

/**
 * Символы, используемые для генерации реферальных кодов
 * Исключены потенциально путаемые символы ('0', 'O', '1', 'l', 'I')
 */
const REF_CODE_CHARS = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789abcdefghijkmnopqrstuvwxyz";

/**
 * Длина реферального кода
 */
const REF_CODE_LENGTH = 8;

/**
 * Генерирует случайный реферальный код
 * Использует криптографически стойкий генератор случайных чисел
 */
export function generateRefCode(): string {
  const bytes = crypto.randomBytes(REF_CODE_LENGTH);
  let result = "";
  
  for (let i = 0; i < REF_CODE_LENGTH; i++) {
    const index = bytes[i] % REF_CODE_CHARS.length;
    result += REF_CODE_CHARS[index];
  }
  
  return result;
}

/**
 * Проверяет, является ли реферальный код уникальным
 */
export async function isRefCodeUnique(refCode: string): Promise<boolean> {
  const existingUser = await db.query.users.findFirst({
    where: eq(users.ref_code, refCode),
  });
  return !existingUser;
}

/**
 * Генерирует уникальный реферальный код
 * При необходимости повторяет генерацию, пока не найдет уникальный код
 */
export async function generateUniqueRefCode(): Promise<string> {
  let refCode = generateRefCode();
  let isUnique = await isRefCodeUnique(refCode);

  // Повторяем генерацию, пока не получим уникальный код
  let attempts = 1;
  const maxAttempts = 20; // Увеличиваем количество попыток

  while (!isUnique && attempts < maxAttempts) {
    refCode = generateRefCode();
    isUnique = await isRefCodeUnique(refCode);
    attempts++;
  }

  if (!isUnique) {
    throw new Error(
      `Не удалось сгенерировать уникальный реферальный код после ${maxAttempts} попыток`,
    );
  }

  return refCode;
}

/**
 * Валидирует реферальный код
 * Проверяет формат и допустимые символы
 */
export function validateRefCode(refCode: string): boolean {
  if (!refCode) return false;
  
  // Проверяем длину
  if (refCode.length !== REF_CODE_LENGTH) return false;
  
  // Проверяем, что все символы допустимы
  return refCode.split('').every(char => REF_CODE_CHARS.includes(char));
}