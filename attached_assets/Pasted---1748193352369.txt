ТЗ: Аудит и стабилизация генерации реферальных кодов

ЦЕЛЬ:
Обеспечить, чтобы каждому пользователю при первой инициализации в системе присваивался уникальный и постоянный реферальный код формата ref_abc123…, который сохраняется в БД и не изменяется.
Исключить автоматическую генерацию temp_ кодов при нормальной работе системы.

⸻

ЗАДАЧИ:

1. Проверить текущую реализацию генерации кода
 • Найти и изучить логику метода generateReferralCode() и isRefCodeUnique()
 • Уточнить: где, когда и кем вызывается fallback-режим с генерацией temp_...
 • Убедиться, что ref_... код создается через криптографически безопасную случайную строку + user_id

2. Проверить логику сохранения в БД
 • Подтвердить, что:
 • ref_code сохраняется в таблице users и/или referral_codes
 • После первой генерации код больше не перезаписывается
 • Уточнить, что в случае повторного входа — не создается новый код

3. Проанализировать механизм fallback (temp_…)
 • Когда и при каких условиях система генерирует временный temp_... код?
 • Проверить, не срабатывает ли fallback из-за:
 • ошибок соединения с БД
 • отсутствия транзакции
 • гонки данных или ошибок в await логике
 • Убедиться, что fallback НЕ используется в продакшене при нормальной работе

4. Проверить прикрепление кода к пользователю
 • Убедиться, что при создании нового пользователя:
 • ref_code присваивается навсегда
 • parent_ref_code сохраняется корректно
 • при повторном входе Telegram initData правильно находит telegram_id

⸻

ТРЕБУЕМЫЕ ВЫХОДНЫЕ ДАННЫЕ:
 1. Подробный отчет:
 • Где хранится код
 • Когда он создается
 • Почему система выдает temp_…
 2. Подтверждение, что fallback не должен срабатывать в продакшене
 3. Убедиться, что каждый пользователь получает только один постоянный ref_code

⸻

ТЕХНИЧЕСКИЕ ОГРАНИЧЕНИЯ:
 • ❌ Не создавать дубликаты кода и не менять архитектуру
 • ❌ Не генерировать temp_... коды, если ref_... может быть создан
 • ✅ Все изменения в логике должны сохранять обратную совместимость
 • ✅ Система должна корректно работать при повторной авторизации

⸻